* Welcome to EASY - Evented Accounting Sourced from Yaml

** Introduction

=easy= is a command line utility which generates artifacts typically
used in accounting (but also other fields of business like invoicing)
based on events provided as [[https://yaml.org/][YAML]] files.

** Overview

In principle =easy= is used to transform the business events given in
YAML into other business artifacts like invoices (PDF documents) or
journal files for use with [[https://www.ledger-cli.org/][ledger]] (a command line utility for plain
text accounting.) Processing of events happens in 5 steps:

1. Read input events
2. Check input events against spec
3. Augment input events
   3.1. Calculate derived values
   3.2. Resolve related events
4. Check augmented event against spec
5. Render event(s) through templates

** Inputs

You can have as many YAML files as you want. Each YAML file contains
one or more events. You are also free to categorize your YAML as you
please. (E.g. We have one file for each customers invoices and a
separate file for all settlements of the invcoices.)

All events are spec'ed in [[https://clojure.org/guides/spec][Clojure Specs]]. Some of the fields are
mandatory, some are optional. See the specs for details. Here are some
example Specs:

- [[src/easy/common.cljs][common]]
- [[src/easy/expense.cljs][expense]]
- [[src/easy/revenue.cljs][revenue]]
  - [[src/easy/revenue/item.cljs][revenue item]]

The easy code base is structured in a way that nested name spaces
reflect the data structure that is used when writing events. (E.g. an
event of type /revenue/ has a field /items/, the spec for items will
be in the name space =revenue.item=.)

*** Example

This is what a typical easy YAML document with one event might look
like.

#+BEGIN_EXAMPLE
---
- type: revenue
  date: 2017-12-04
  customer: 6
  number: 2
  version: 1
  deadline: 30
  items:
    - rate: 200
      hours: 13.5
      beneficiary: phil
      discount: 0
      timesheet: path/to/timesheet.csv
#+END_EXAMPLE

** Install

Easy runs on [[http://lumo-cljs.org/][lumo]] and uses node packages available via [[https://www.npmjs.com/][npm]], as well as
ClojureScript packages available via [[https://clojars.org/][clojars]] (maven).

Hence you will need to install the npm dependencies via =npm install=.

ClojureScript dependencies tracked in =deps.edn= are installed via
=clj= (aka. Clojure CLI). Please install =clj= as described [[https://clojure.org/guides/deps_and_cli][here]].

Additionally [[https://github.com/kislyuk/yq][yq]] is like [[https://stedolan.github.io/jq/][jq]] for YAML, it is actually a wrapper around
jq. It comes in really handy if working with multiple YAML files.

#+BEGIN_SRC sh
sudo apt install python-pip
pip install yq
#+END_SRC

** Usage

*** Examples

Render ledger entries from events and run the through ledger to create
a balance:

=easy ledger example.yml | ledger bal -f -=

Render invoice 18.2.1 to latex:

=easy invoice example.yml 18.2.1=

Just run a transform to see the transformed events, which is handy for
writing templates:

=easy transform example.yml=

** Resolve & Context

Easy uses a multimethod =transform= to transform events into a
/usable/ form. /Usable/ meaning it has all the details calculated and
associated data added to be used in a template.

The transformation of a single event might happen within a =context=.
The =context= is the set of all events within a processing run.
(Technically the =context= is not a set, but a map, where the values
are lists of events and the keys are their corresponding =type=. This
is for convenience because in almost all cases you only want to have
events of a single =type= when using the context to resolve associated
events.)

Associated data is added via resolve-fns. The resolve-fns use the
context to lookup other events. As the context contains only "mildy"
and not fully transformed events the resolve-fn will very likely have
to transform the resolved event in order to make it usable. If this
would mean that another resolve-fn is triggerd this will likely
trigger an endless recursion of resolves.

To prevent this from happening you have to adhere to the following
conventions: (A) Resolve functions that receive =nil= as the =context=
should return the event untouched. (B) When calling =transform= from a
resolve-fn, always pass =nil= as the =context=.
